// ==UserScript==
// @name         QIshan今天抢到座位了吗 - V1.7.0 动态优先级增强版
// @namespace    https://github.com/qishangjh/Libseat
// @version      1.7.0
// @description  为吉林大学图书馆座位预约系统 (libseat.jlu.edu.cn) 创建的 Tampermonkey 用户脚本，包含动态优先级排序和分类修复。
// @author       QIshan
// @match        https://libseat.jlu.edu.cn/pages/reserve/seat-reserve/seat-choose-v2*
// @grant        GM_log
// @grant        GM.info
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_notification
// @run-at       document-end
// @license      MIT
// ==/UserScript==

(function() {
    'use strict';

    // =================================================================================
    // --- [模块] 工具函数 (Utils) ---
    // =================================================================================
    const Utils = {
        ruleRegexCache: new Map(),
        seatCheckCache: new Map(),
        DISTANCE_SORT_TARGET_SEAT: 40,
        TARGET_COMPONENT_NAME: "SeatChooseV2",

        async log(...args) {
            console.log(`[${GM.info.script.name}]`, ...args);
            try { await GM_log(`[${GM.info.script.name}]`, ...args); } catch (e) { /* silent */ }
        },
        async error(...args) {
            console.error(`[${GM.info.script.name} ERROR]`, ...args);
            try { await GM_log(`[${GM.info.script.name} ERROR]`, ...args); } catch (e) { /* silent */ }
        },

        parseSeatNumberFromName(seatName) {
            if (!seatName) return NaN;
            const matches = seatName.match(/\d+/g);
            return matches && matches.length > 0 ? parseInt(matches[matches.length - 1], 10) : NaN;
        },

        compileRule(ruleString) {
            if (this.ruleRegexCache.has(ruleString)) return this.ruleRegexCache.get(ruleString);
            let rule;
            if (ruleString === "剩余的") {
                rule = { type: "remaining" };
            } else if (ruleString.match(/(\d+)\+(\d+)n,\s*n<(\d+)/)) {
                const p = ruleString.match(/(\d+)\+(\d+)n,\s*n<(\d+)/);
                rule = { type: "series", a: parseInt(p[1], 10), b: parseInt(p[2], 10), m: parseInt(p[3], 10) };
            } else if (ruleString.match(/(\d+)-(\d+)/)) {
                const p = ruleString.match(/(\d+)-(\d+)/);
                rule = { type: "range", start: parseInt(p[1], 10), end: parseInt(p[2], 10) };
            } else {
                rule = { type: "unknown" };
            }
            this.ruleRegexCache.set(ruleString, rule);
            return rule;
        },

        matchesPreferenceRule(ruleString, seatNumber) {
            if (!ruleString || isNaN(seatNumber)) return false;
            const rule = this.compileRule(ruleString);
            switch (rule.type) {
                case "remaining": return true;
                case "series": return Array.from({ length: rule.m }, (_, n) => rule.a + rule.b * n).includes(seatNumber);
                case "range": return seatNumber >= rule.start && seatNumber <= rule.end;
                default: return false;
            }
        },

        getTomorrowFormattedDate() {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const yyyy = tomorrow.getFullYear();
            const mm = String(tomorrow.getMonth() + 1).padStart(2, '0');
            const dd = String(tomorrow.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        },

        debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        },

        safeClick(element) {
            if (!element) return false;
            try {
                element.click();
                return true;
            } catch (e) {
                Utils.error('Click failed:', e);
                return false;
            }
        },

        findVueInstance(rootVm, componentName) {
            if (!rootVm) return null;
            const vueInstance = rootVm.$vm || rootVm;
            if (!vueInstance || typeof vueInstance !== 'object') return null;
            const name = vueInstance.$options?.name || vueInstance.$options?._componentTag;
            if (name === componentName) return vueInstance;
            if (vueInstance.$children && vueInstance.$children.length > 0) {
                for (const child of vueInstance.$children) {
                    const childVm = this.findVueInstance(child, componentName);
                    if (childVm) return childVm;
                }
            }
            return null;
        },

        async waitForUniAppPageVm() {
            await this.log('Attempting to find UniApp Vue instance...');
            return new Promise((resolve) => {
                let retryCount = 0;
                const maxRetries = 180; // 36 seconds
                const interval = setInterval(async () => {
                    if (retryCount++ > maxRetries) {
                        clearInterval(interval);
                        await this.error('Max retries reached for finding root Vue instance.');
                        return resolve(null);
                    }
                    if (typeof getCurrentPages === 'function') {
                        const pages = getCurrentPages();
                        if (pages && pages.length > 0) {
                            const rootVm = pages[pages.length - 1]?.$vm;
                            const foundVm = this.findVueInstance(rootVm, this.TARGET_COMPONENT_NAME);
                            if (foundVm) {
                                clearInterval(interval);
                                await this.log(`Successfully found "${this.TARGET_COMPONENT_NAME}" VM.`);
                                return resolve(foundVm);
                            }
                        }
                    }
                }, 200);
            });
        }
    };

    // =================================================================================
    // --- [模块] 配置管理器 (ConfigManager) ---
    // =================================================================================
    const ConfigManager = {
        key: 'libseat_auto_reserve_config_v1_5_1',
        config: {},
        defaultConfig: {
            autoStartAtSpecificTime: true,
            startHour: 21, startMinute: 0, startSecond: 1,
            targetDate: "", targetStartTime: "08:00", targetEndTime: "22:00",
            // [核心修改] 调整规则顺序以修复分类逻辑，priority仅用于排序
            seatPreferences: {
                "3F": [
                    // 把具体的规则放在前面，以确保正确分类
                    { type: "大理石", rule: "29-59", priority: 2 },
                    { type: "中间", rule: "61+3n, n<12", priority: 3 },
                    // 把“包底”的规则放在最后，但priority值更高，确保默认排序优先
                    { type: "靠边", rule: "剩余的", priority: 1 }
                ],
                "2F": [
                    // 同样，把更具体的规则放在前面
                    { type: "大理石", rule: "85-102", priority: 2 },
                    { type: "中间", rule: "2+3n, n<12", priority: 3 },
                    { type: "靠边", rule: "37-84", priority: 1 }
                ]
            },
            globalBlacklistKeywords: ["设备损坏", "禁"],
            autoConfirmReservation: true,
            retryInterval: 2000, randomizeDelay: 500,
            postActionMaxWait: 5000, postActionMinDelay: 200,
            uiSelectedFloor: "3F", uiSelectedPreference: "auto",
            uiPreferredSeatNumber: "", uiPanelMinimized: true,
            refreshInterval: 1500,
            postSelectionDelay: 300,
        },

        async load() {
            try {
                const storedConfig = await GM_getValue(this.key, null);
                this.config = { ...this.defaultConfig, ...storedConfig };
                if (!this.config.targetDate || !/^\d{4}-\d{2}-\d{2}$/.test(this.config.targetDate)) {
                    this.config.targetDate = Utils.getTomorrowFormattedDate();
                }
                await Utils.log("Configuration loaded:", this.config);
            } catch (e) {
                await Utils.error("Failed to load configuration:", e);
                this.config = { ...this.defaultConfig };
                this.config.targetDate = Utils.getTomorrowFormattedDate();
            }
        },

        async save() {
            try {
                const configToSave = {
                    autoStartAtSpecificTime: this.config.autoStartAtSpecificTime,
                    startHour: this.config.startHour, startMinute: this.config.startMinute, startSecond: this.config.startSecond,
                    targetDate: this.config.targetDate, targetStartTime: this.config.targetStartTime, targetEndTime: this.config.targetEndTime,
                    uiSelectedFloor: this.config.uiSelectedFloor, uiSelectedPreference: this.config.uiSelectedPreference,
                    uiPreferredSeatNumber: this.config.uiPreferredSeatNumber, uiPanelMinimized: this.config.uiPanelMinimized,
                    autoConfirmReservation: this.config.autoConfirmReservation,
                    refreshInterval: this.config.refreshInterval,
                    postSelectionDelay: this.config.postSelectionDelay,
                    postActionMaxWait: this.config.postActionMaxWait,
                };
                await GM_setValue(this.key, configToSave);
                await Utils.log("Configuration saved.");
            } catch (e) {
                await Utils.error("Failed to save configuration:", e);
            }
        },
        debouncedSave: Utils.debounce(() => ConfigManager.save(), 500),

        get(key) { return this.config[key]; },
        set(key, value, shouldSave = true) {
            this.config[key] = value;
            if (shouldSave) {
                this.debouncedSave();
            }
        }
    };

    // =================================================================================
    // --- [模块] Vue 适配器 (VueAdapter) ---
    // =================================================================================
    const VueAdapter = {
        vm: null,
        init(vueInstance) {
            this.vm = vueInstance;
        },

        _callVmMethod(methodNames, ...args) {
            for (const name of methodNames) {
                if (typeof this.vm[name] === 'function') {
                    Utils.log(`Calling VM method: ${name}`);
                    return this.vm[name](...args);
                }
            }
            throw new Error(`No known VM method found from: [${methodNames.join(', ')}]`);
        },

        async getSeats() {
            return this._callVmMethod(['getSeats', 'getSeatList', 'refreshSeats', 'loadSeats']);
        },

        async selectSeat(seat) {
            if (typeof this.vm.selectSeat === 'function') {
                return this.vm.selectSeat({ seat, index: this.vm.seatList.findIndex(s => s.id === seat.id) });
            }
            return this._callVmMethod(['handleSeatClick'], seat);
        },

        async confirmReservation(seat) {
            return this._callVmMethod(['confirmReservation', 'submitReservation', 'reserveSeat'], seat);
        },

        async setTimeRange(date, startTime, endTime) {
            if (!this.vm.timeRange) throw new Error('vm.timeRange is not available.');
            this.vm.timeRange.date = date;
            this.vm.timeRange.startTime = startTime;
            this.vm.timeRange.endTime = endTime;
            if (typeof this.vm.$set === 'function') {
                this.vm.$set(this.vm.timeRange, 'date', date);
                this.vm.$set(this.vm.timeRange, 'startTime', startTime);
                this.vm.$set(this.vm.timeRange, 'endTime', endTime);
            }
            await new Promise(r => setTimeout(r, ConfigManager.get('postActionMinDelay')));
            await Utils.log('Time range updated in VM.');
        }
    };

    // =================================================================================
    // --- [模块] UI 管理器 (UIManager) ---
    // =================================================================================
    const UIManager = {
        elements: {},
        isReady: false,
        quickTimeRanges: [
            { name: "全天", start: "08:15", end: "21:45" },
            { name: "上午", start: "08:15", end: "12:00" },
            { name: "下午1", start: "12:20", end: "15:20" },
            { name: "下午2", start: "15:00", end: "18:00" },
            { name: "晚上", start: "18:00", end: "21:45" }
        ],

        create() {
            if (document.getElementById('libseat-reservation-panel')) {
                Utils.log('UI panel already exists. Re-initializing.');
                this.initialize();
                return;
            }
            const panel = document.createElement('div');
            panel.id = 'libseat-reservation-panel';
            panel.innerHTML = `
                <style>
                    #libseat-reservation-panel{position:fixed;top:20px;right:20px;z-index:9999;background:white;padding:15px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.2);font-family:sans-serif;font-size:14px;color:#333;transition:all .3s ease;width:350px}
                    #libseat-reservation-panel *{box-sizing:border-box}#libseat-reservation-panel .header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;padding-bottom:5px;border-bottom:1px solid #eee}
                    #libseat-reservation-panel h3{margin:0;font-size:16px}#libseat-reservation-panel button{background:0;border:0;cursor:pointer;font-size:16px;color:#666}#libseat-reservation-panel button:hover{color:#000}
                    #libseat-reservation-panel label{display:block;margin-bottom:5px;font-weight:700;color:#555}
                    #libseat-reservation-panel select,#libseat-reservation-panel input{width:100%;padding:8px;margin-bottom:10px;border:1px solid #ddd;border-radius:4px;font-size:14px}
                    #libseat-reservation-panel .input-group-row{display:flex;gap:8px;align-items:center}
                    #libseat-reservation-panel .quick-time-ranges{display:flex;flex-wrap:wrap;gap:5px;margin-bottom:10px}
                    #libseat-reservation-panel .quick-time-btn{padding:5px 10px;font-size:12px;background:#f0f0f0;border:1px solid #ccc;border-radius:4px;color:#555}
                    #libseat-reservation-panel .quick-time-btn:hover{background:#e0e0e0}
                    #libseat-reservation-panel .action-btn{padding:10px;border:0;border-radius:4px;color:#fff;font-weight:700;cursor:pointer;font-size:15px;transition:background .2s}
                    #libseat-reservation-panel #start-reserve-btn{background:#4CAF50}#libseat-reservation-panel #start-reserve-btn:hover{background:#43A047}
                    #libseat-reservation-panel #reset-reserve-btn{background:#FF9800}#libseat-reservation-panel #reset-reserve-btn:hover{background:#FB8C00}
                    #libseat-reservation-panel #refresh-seats-btn{background:#2196F3}#libseat-reservation-panel #refresh-seats-btn:hover{background:#1976D2}
                    #libseat-reservation-panel #reservation-status{padding:10px;background:#f8f9fa;border-radius:4px;min-height:20px;color:#333;margin-top:15px;font-size:13px;text-align:center;border:1px solid #dee2e6;transition:all .3s}
                    #libseat-reservation-panel #minimized-panel-content{display:none;flex-direction:column;gap:8px;margin-top:5px}
                    #libseat-reservation-panel #minimized-panel-content button{background-color:#f8f8f8;border:1px solid #e0e0e0;padding:8px 10px;font-size:13px;border-radius:4px;width:100%;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
                    .settings-container{display:none;border-top:1px solid #eee;margin-top:10px;padding-top:10px}
                    #toggle-all-settings{font-size:12px;color:#007bff;text-decoration:none;cursor:pointer;float:right;margin-top:-5px;margin-bottom:5px}
                    .settings-header{font-weight:bold;margin-top:5px;margin-bottom:8px;font-size:13px;color:#333}
                </style>
                <div class="header"><h3>QIshan今天抢到座位了吗</h3><button id="minimize-panel">▴</button></div>
                <div id="minimized-panel-content">
                    <button id="minimized-start-reserve-btn" title="点击立即开始抢座">手动立刻抢座</button>
                    <button id="minimized-show-time-btn" title="点击展开设置面板">预约时间: 就绪</button>
                </div>
                <div id="panel-content">
                    <div class="input-group-row"><div style="flex:1"><label for="floor-select">楼层:</label><select id="floor-select"></select></div><div style="flex:1"><label for="preference-select">地段偏好:</label><select id="preference-select"></select></div></div>
                    <div class="input-group-row">
                        <div style="flex: 1 1 40%;"><label for="res-date-input">预约日期:</label><input type="date" id="res-date-input"></div>
                        <div style="flex: 1 1 60%;"><label>时间段:</label><div class="input-group-row"><input type="time" id="res-start-time" style="flex:1;"><span>-</span><input type="time" id="res-end-time" style="flex:1;"></div></div>
                    </div>
                    <div class="quick-time-ranges">${this.quickTimeRanges.map(r=>`<button class="quick-time-btn" data-start="${r.start}" data-end="${r.end}">${r.name}</button>`).join('')}</div>
                    <div><label for="preferred-seat-number">喜欢座位号:</label><input type="text" id="preferred-seat-number" placeholder="如: 40, 41 (逗号分隔)"></div>
                    <a href="#" id="toggle-all-settings">展开设置...</a>
                    <div id="all-settings-container" class="settings-container">
                        <div class="settings-header">自动化设置</div>
                        <div class="input-group-row" style="margin-bottom:10px;">
                           <label style="margin-bottom:0;flex:1" for="auto-start-toggle"><input type="checkbox" id="auto-start-toggle" style="width:auto;margin-right:5px;">定时抢座</label>
                           <label style="margin-bottom:0;flex:1" for="auto-confirm"><input type="checkbox" id="auto-confirm" style="width:auto;margin-right:5px;">自动确认</label>
                        </div>
                        <div id="auto-start-time-inputs" style="display:none;">
                            <div class="input-group-row"><div style="flex:1"><label for="start-hour">时:</label><input type="number" id="start-hour" min="0" max="23"></div><div style="flex:1"><label for="start-minute">分:</label><input type="number" id="start-minute" min="0" max="59"></div><div style="flex:1"><label for="start-second">秒:</label><input type="number" id="start-second" min="0" max="59"></div></div>
                        </div>
                        <div class="settings-header">高级速度设置 (谨慎修改)</div>
                        <div class="input-group-row">
                            <div style="flex:1"><label for="rs-refresh-interval" title="每次刷新座位列表之间的等待时间。过低可能被服务器拒绝。">刷新(ms):</label><input type="number" id="rs-refresh-interval" min="100" step="100"></div>
                            <div style="flex:1"><label for="rs-post-selection-delay" title="点击座位后，等待确认弹窗出现的延迟。">延迟(ms):</label><input type="number" id="rs-post-selection-delay" min="50" step="50"></div>
                            <div style="flex:1"><label for="rs-outcome-timeout" title="点击确认后，等待成功/失败结果的最长时间。">超时(ms):</label><input type="number" id="rs-outcome-timeout" min="1000" step="500"></div>
                        </div>
                    </div>
                    <div style="display:flex;gap:10px;margin-top:15px"><button id="start-reserve-btn" class="action-btn" style="flex:2">开始抢座</button><button id="refresh-seats-btn" class="action-btn" style="flex:1">刷新</button><button id="reset-reserve-btn" class="action-btn" style="flex:2;display:none">重置抢座</button></div>
                    <div id="reservation-status">就绪，请设置参数并点击开始</div>
                </div>
            `;
            document.body.appendChild(panel);
            Utils.log('UI panel created and appended to body.');
            this.initialize();
        },

        initialize() {
            const ids = [
                'libseat-reservation-panel', 'floor-select', 'preference-select',
                'res-date-input', 'res-start-time', 'res-end-time', 'preferred-seat-number',
                'auto-confirm', 'auto-start-toggle', 'start-hour', 'start-minute', 'start-second',
                'start-reserve-btn', 'reset-reserve-btn', 'refresh-seats-btn', 'minimize-panel',
                'minimized-start-reserve-btn', 'minimized-show-time-btn', 'panel-content',
                'minimized-panel-content', 'reservation-status',
                'rs-refresh-interval', 'rs-post-selection-delay', 'rs-outcome-timeout',
                'toggle-all-settings', 'all-settings-container', 'auto-start-time-inputs'
            ];
            this.elements = ids.reduce((acc, id) => {
                const camelCaseKey = id.replace(/-(\w)/g, (_, c) => c.toUpperCase());
                acc[camelCaseKey] = document.getElementById(id);
                return acc;
            }, {});
            this.elements.statusEl = this.elements.reservationStatus;
            this.applyConfigToUI();
            if (!this.elements.libseatReservationPanel.dataset.listenersAdded) {
                this.setupEventListeners();
                this.elements.libseatReservationPanel.dataset.listenersAdded = 'true';
            }
            this.togglePanelVisibility(ConfigManager.get('uiPanelMinimized'), true);
            this.isReady = true;
        },

        applyConfigToUI() {
            this.elements.resDateInput.value = ConfigManager.get('targetDate');
            this.elements.resStartTime.value = ConfigManager.get('targetStartTime');
            this.elements.resEndTime.value = ConfigManager.get('targetEndTime');
            this.elements.preferredSeatNumber.value = ConfigManager.get('uiPreferredSeatNumber');
            this.elements.autoConfirm.checked = ConfigManager.get('autoConfirmReservation');
            this.elements.autoStartToggle.checked = ConfigManager.get('autoStartAtSpecificTime');
            this.elements.startHour.value = ConfigManager.get('startHour');
            this.elements.startMinute.value = ConfigManager.get('startMinute');
            this.elements.startSecond.value = ConfigManager.get('startSecond');
            this.elements.rsRefreshInterval.value = ConfigManager.get('refreshInterval');
            this.elements.rsPostSelectionDelay.value = ConfigManager.get('postSelectionDelay');
            this.elements.rsOutcomeTimeout.value = ConfigManager.get('postActionMaxWait');
            this.elements.autoStartTimeInputs.style.display = this.elements.autoStartToggle.checked ? 'block' : 'none';
        },

        setupEventListeners() {
            this.elements.minimizePanel.addEventListener('click', () => this.togglePanelVisibility(!ConfigManager.get('uiPanelMinimized')));
            this.elements.minimizedStartReserveBtn.addEventListener('click', () => ReservationEngine.manualStart());
            this.elements.minimizedShowTimeBtn.addEventListener('click', () => this.togglePanelVisibility(false));
            this.elements.startReserveBtn.addEventListener('click', () => ReservationEngine.manualStart());
            this.elements.resetReserveBtn.addEventListener('click', () => ReservationEngine.stop());
            this.elements.refreshSeatsBtn.addEventListener('click', () => ReservationEngine.manualRefresh());
            const inputs = {
                'res-date-input': 'targetDate', 'res-start-time': 'targetStartTime', 'res-end-time': 'targetEndTime',
                'preferred-seat-number': 'uiPreferredSeatNumber', 'start-hour': 'startHour', 'start-minute': 'startMinute', 'start-second': 'startSecond'
            };
            for (const [id, key] of Object.entries(inputs)) {
                document.getElementById(id).addEventListener('change', (e) => ConfigManager.set(key, e.target.value));
            }
            this.elements.toggleAllSettings.addEventListener('click', (e) => {
                e.preventDefault();
                const container = this.elements.allSettingsContainer;
                const isVisible = container.style.display === 'block';
                container.style.display = isVisible ? 'none' : 'block';
                e.target.textContent = isVisible ? '展开设置...' : '收起设置';
            });
            this.elements.autoConfirm.addEventListener('change', (e) => ConfigManager.set('autoConfirmReservation', e.target.checked));
            this.elements.autoStartToggle.addEventListener('change', (e) => {
                ConfigManager.set('autoStartAtSpecificTime', e.target.checked);
                this.elements.autoStartTimeInputs.style.display = e.target.checked ? 'block' : 'none';
            });
            const speedInputs = {
                'rs-refresh-interval': 'refreshInterval',
                'rs-post-selection-delay': 'postSelectionDelay',
                'rs-outcome-timeout': 'postActionMaxWait'
            };
            for (const [id, key] of Object.entries(speedInputs)) {
                document.getElementById(id).addEventListener('change', (e) => ConfigManager.set(key, parseInt(e.target.value, 10)));
            }
            this.elements.floorSelect.addEventListener('change', (e) => {
                ConfigManager.set('uiSelectedFloor', e.target.value);
                this.updateFloorAndPreferenceOptions();
            });
            this.elements.preferenceSelect.addEventListener('change', (e) => ConfigManager.set('uiSelectedPreference', e.target.value));
            this.elements.panelContent.querySelector('.quick-time-ranges').addEventListener('click', (event) => {
                const btn = event.target.closest('.quick-time-btn');
                if (!btn) return;
                this.elements.resStartTime.value = btn.dataset.start;
                this.elements.resEndTime.value = btn.dataset.end;
                ConfigManager.set('targetStartTime', btn.dataset.start, false);
                ConfigManager.set('targetEndTime', btn.dataset.end);
            });
        },

        togglePanelVisibility(isMinimized, skipSave = false) {
            ConfigManager.set('uiPanelMinimized', isMinimized, !skipSave);
            this.elements.panelContent.style.display = isMinimized ? 'none' : 'block';
            this.elements.minimizedPanelContent.style.display = isMinimized ? 'flex' : 'none';
            this.elements.minimizePanel.textContent = isMinimized ? '▾' : '▴';
            this.elements.libseatReservationPanel.style.width = isMinimized ? '220px' : '350px';
            this.updateTimerDisplay();
        },

        updateStatus(message, statusType = 'info') {
            if (!this.isReady) {
                Utils.log(`[Status Update] ${message}`);
                return;
            }
            this.elements.statusEl.textContent = message;
            const styles = {
                info: { bg: '#f8f9fa', border: '#dee2e6', color: '#333' },
                working: { bg: '#e3f2fd', border: '#2196F3', color: '#0d47a1' },
                success: { bg: '#e8f5e9', border: '#4CAF50', color: '#1b5e20' },
                error: { bg: '#ffebee', border: '#F44336', color: '#c62828' }
            };
            const style = styles[statusType] || styles.info;
            this.elements.statusEl.style.backgroundColor = style.bg;
            this.elements.statusEl.style.borderColor = style.border;
            this.elements.statusEl.style.color = style.color;
        },

        async updateFloorAndPreferenceOptions() {
            if (!this.isReady) return;
            const floorSelect = this.elements.floorSelect;
            const prefSelect = this.elements.preferenceSelect;
            floorSelect.innerHTML = '<option value="auto">自动检测楼层</option>';
            prefSelect.innerHTML = '<option value="auto">按优先级自动选择</option>';
            Object.keys(ConfigManager.get('seatPreferences')).forEach(floor => {
                floorSelect.add(new Option(floor, floor));
            });
            floorSelect.value = ConfigManager.get('uiSelectedFloor');
            const selectedFloor = floorSelect.value === 'auto'
                ? await ReservationEngine.getDetectedFloor()
                : floorSelect.value;
            if (selectedFloor && ConfigManager.get('seatPreferences')[selectedFloor]) {
                ConfigManager.get('seatPreferences')[selectedFloor].forEach(pref => {
                    prefSelect.add(new Option(pref.type, pref.type));
                });
            }
            prefSelect.value = ConfigManager.get('uiSelectedPreference');
        },

        updateTimerDisplay() {
            if (!this.isReady) return;
            const { startReserveBtn, resetReserveBtn, minimizedStartReserveBtn, minimizedShowTimeBtn } = this.elements;
            const isMinimized = ConfigManager.get('uiPanelMinimized');
            if (ReservationEngine.isActive) {
                startReserveBtn.style.display = 'none';
                resetReserveBtn.style.display = isMinimized ? 'none' : 'inline-block';
                minimizedStartReserveBtn.disabled = true;
                minimizedStartReserveBtn.textContent = '抢座中...';
            } else {
                startReserveBtn.style.display = isMinimized ? 'none' : 'inline-block';
                resetReserveBtn.style.display = 'none';
                minimizedStartReserveBtn.disabled = false;
                minimizedStartReserveBtn.textContent = '手动立刻抢座';
                if (ConfigManager.get('autoStartAtSpecificTime') && ReservationEngine.nextAutoStartTime) {
                    const diff = ReservationEngine.nextAutoStartTime.getTime() - Date.now();
                    if (diff > 0) {
                        const totalSeconds = Math.floor(diff / 1000);
                        const h = String(Math.floor(totalSeconds / 3600)).padStart(2,'0');
                        const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2,'0');
                        const s = String(totalSeconds % 60).padStart(2,'0');
                        minimizedShowTimeBtn.textContent = `下次自动: ${h}:${m}:${s}`;
                    }
                } else {
                    minimizedShowTimeBtn.textContent = '预约时间: 就绪';
                }
            }
        }
    };

    // =================================================================================
    // --- [模块] 核心抢座引擎 (ReservationEngine) ---
    // =================================================================================
    const ReservationEngine = {
        vm: null,
        reservationTimer: null,
        autoStartTimer: null,
        nextAutoStartTime: null,
        isActive: false,
        attempts: 0,
        MAX_ATTEMPTS: 5,
        FETCH_SEAT_MAX_RETRIES: 3,
        FETCH_SEAT_RETRY_DELAY: 1000,

        async init(vueInstance) {
            this.vm = vueInstance;
            VueAdapter.init(vueInstance);
            await UIManager.updateFloorAndPreferenceOptions();
            this.scheduleAutoStart();
        },

        async getDetectedFloor() {
            if (!this.vm || !this.vm.readingRoom) return null;
            const path = this.vm.readingRoom.parentNamePath || this.vm.readingRoom.name || '';
            const match = path.match(/(\d+F)/);
            return match ? match[1] : null;
        },

        async scheduleAutoStart() {
            if (this.autoStartTimer) clearTimeout(this.autoStartTimer);
            this.nextAutoStartTime = null;
            if (!ConfigManager.get('autoStartAtSpecificTime')) {
                UIManager.updateStatus('定时抢座已关闭。');
                return;
            }
            const now = new Date();
            let targetTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), ConfigManager.get('startHour'), ConfigManager.get('startMinute'), ConfigManager.get('startSecond'));
            if (targetTime <= now) targetTime.setDate(targetTime.getDate() + 1);
            const delay = targetTime.getTime() - now.getTime();
            this.nextAutoStartTime = targetTime;
            UIManager.updateStatus(`定时任务已设定，将于 ${targetTime.toLocaleString('zh-CN')} 自动抢座。`);
            this.autoStartTimer = setTimeout(() => this.start(true), delay);
            setInterval(() => UIManager.updateTimerDisplay(), 1000);
        },

        manualStart() {
            this.stop(false);
            this.start(true);
        },
        
        stop(notify = true, reschedule = true) {
            if (this.reservationTimer) clearTimeout(this.reservationTimer);
            if (this.autoStartTimer) clearTimeout(this.autoStartTimer);
            this.reservationTimer = null;
            this.isActive = false;
            if (notify) {
                UIManager.updateStatus('抢座已停止。');
            }
            if (reschedule) {
                this.scheduleAutoStart();
            }
            UIManager.updateTimerDisplay();
        },

        async start(isNewRun = false) {
            if (isNewRun) this.attempts = 0;
            this.isActive = true;
            UIManager.updateTimerDisplay();
            if (this.attempts >= this.MAX_ATTEMPTS) {
                UIManager.updateStatus(`已达到最大抢座尝试次数 (${this.MAX_ATTEMPTS}次)，停止。`, 'error');
                GM_notification({ title: GM.info.script.name, text: '抢座失败，已达到最大尝试次数。', timeout: 8000 });
                this.stop(false, false);
                return;
            }
            this.attempts++;
            UIManager.updateStatus(`第 ${this.attempts}/${this.MAX_ATTEMPTS} 次尝试抢座...`, 'working');
            if (!this.vm) {
                UIManager.updateStatus('错误: Vue 实例丢失，无法继续。', 'error');
                this.stop(true, false);
                return;
            }
            try {
                await this.executeReservationFlow();
            } catch (e) {
                await Utils.error('Reservation flow caught an error:', e);
                UIManager.updateStatus(`尝试失败: ${e.message}`, 'error');
                this.scheduleNextAttempt();
            }
        },

        async executeReservationFlow() {
            const { targetDate, targetStartTime, targetEndTime, uiSelectedFloor, uiPreferredSeatNumber } = ConfigManager.config;
            UIManager.updateStatus(`第 ${this.attempts} 次尝试: 设置时间范围...`, 'working');
            await VueAdapter.setTimeRange(targetDate, targetStartTime, targetEndTime);
            let sortedSeats = [];
            const EMPTY_FETCH_RETRIES = 3;
            const refreshDelay = ConfigManager.get('refreshInterval');
            for (let i = 0; i < EMPTY_FETCH_RETRIES; i++) {
                UIManager.updateStatus(`第 ${i + 1}/${EMPTY_FETCH_RETRIES} 次刷新座位列表...`, 'working');
                const fetchSuccess = await this.ensureSeatListIsFetched();
                if (!fetchSuccess) {
                    throw new Error('获取座位列表失败，请检查网络。');
                }
                const preferredSeatNumbers = (uiPreferredSeatNumber || '').split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n));
                let floorForSorting = uiSelectedFloor === 'auto' ? await this.getDetectedFloor() : uiSelectedFloor;
                if (!floorForSorting) {
                    Utils.log("无法自动检测楼层, 使用默认 3F 进行排序。");
                    floorForSorting = "3F";
                }
                const currentFoundSeats = this.filterAndSortSeats(this.vm.seatList, floorForSorting, preferredSeatNumbers);
                UIManager.updateStatus(`当前可选座位: ${currentFoundSeats.length}`, 'info');
                if (currentFoundSeats.length > 0) {
                    sortedSeats = currentFoundSeats;
                    break;
                }
                if (i < EMPTY_FETCH_RETRIES - 1) {
                    await new Promise(r => setTimeout(r, refreshDelay));
                }
            }
            if (sortedSeats.length === 0) {
                UIManager.updateStatus('当前可选座位：0 请更换时间', 'error');
                GM_notification({ title: GM.info.script.name, text: '多次刷新后仍无空闲座位，抢座已停止。'});
                this.stop(false, false);
                return;
            }
            UIManager.updateStatus(`锁定 ${sortedSeats.length} 个目标座位，尝试预约...`, 'working');
            for (const seat of sortedSeats.slice(0, 3)) {
                const success = await this.selectAndReserveSeat(seat);
                if (success) {
                    UIManager.updateStatus(`成功预约座位: ${seat.name}!`, 'success');
                    Utils.log(`Successfully reserved seat: ${seat.name}`);
                    GM_notification({ title: GM.info.script.name, text: `成功预约到座位: ${seat.name}！`, image: 'https://www.jlu.edu.cn/__local/A/24/7D/2920253818AFBB1F55C97500B6E_67995171_B10E6.jpg', timeout: 10000 });
                    this.stop(false, true);
                    return;
                }
                if (!this.isActive) return;
            }
            throw new Error('本轮所有候选座位均预约失败。');
        },

        async selectAndReserveSeat(seat) {
            UIManager.updateStatus(`尝试预约座位 ${seat.name}...`, 'working');
            try {
                await VueAdapter.selectSeat(seat);
                await new Promise(r => setTimeout(r, ConfigManager.get('postActionMinDelay') + ConfigManager.get('postSelectionDelay')));
                if (!this.vm.seatReserveVisible) {
                    await Utils.error('Reservation modal did not appear.');
                    return false;
                }
                if (!ConfigManager.get('autoConfirmReservation')) {
                    UIManager.updateStatus('模态框已打开，请手动确认。');
                    this.stop(false);
                    return true;
                }
                const initialUrl = window.location.href;
                this.vm.reservationResult = null;
                try {
                    await VueAdapter.confirmReservation(seat);
                } catch(e) {
                    Utils.log('VM confirm method failed, falling back to DOM click. Error:', e.message);
                    const confirmButton = document.querySelector('.seat-btn.seat-btn-primary, .btn-primary, button.primary');
                    if (confirmButton) Utils.safeClick(confirmButton);
                    else {
                        await Utils.error('Could not find confirm button for DOM click fallback.');
                        return false;
                    }
                }
                const outcome = await this.checkReservationOutcome(initialUrl);
                if (outcome.status === 'success') {
                    return true;
                } else {
                    UIManager.updateStatus(`预约 ${seat.name} 失败: ${outcome.message}`, 'error');
                    if (outcome.status === 'failure_existing_reservation') {
                        UIManager.updateStatus(`预约失败: ${outcome.message} (已停止抢座)`, 'error');
                        this.stop(false, false);
                    }
                    return false;
                }
            } catch (e) {
                await Utils.error('Error during seat selection/confirmation:', e);
                return false;
            }
        },

        async checkReservationOutcome(initialUrl) {
            const MAX_WAIT = ConfigManager.get('postActionMaxWait');
            let elapsedTime = 0;
            return new Promise(resolve => {
                const interval = setInterval(async () => {
                    elapsedTime += 100;
                    if (window.location.href !== initialUrl && window.location.href.includes('/pages/user/')) {
                        clearInterval(interval);
                        return resolve({ status: 'success', message: '页面已跳转至用户中心。' });
                    }
                    const errorMsg = document.querySelector('.uni-toast-content, .uni-modal-content, .error-message');
                    if (errorMsg && errorMsg.offsetParent !== null) {
                        const text = errorMsg.textContent.trim();
                        if (text.includes('已有其他申请或预约')) {
                            clearInterval(interval);
                            return resolve({ status: 'failure_existing_reservation', message: text });
                        } else if (text.includes('失败') || text.includes('不可预约') || text.includes('被占用')) {
                            clearInterval(interval);
                            return resolve({ status: 'failure', message: text });
                        }
                    }
                    if (elapsedTime >= MAX_WAIT) {
                        clearInterval(interval);
                        return resolve({ status: 'timeout', message: '等待预约结果超时。' });
                    }
                }, 100);
            });
        },

        // [核心修改] 替换为最终的、支持动态优先级的排序函数
        filterAndSortSeats(seatList, floorId, preferredSeatNumbers) {
            const preferences = ConfigManager.get('seatPreferences')[floorId] || [];
            const blacklist = ConfigManager.get('globalBlacklistKeywords');
            // 获取用户在UI上的地段选择
            const uiPref = UIManager.elements.preferenceSelect.value;

            const validSeats = seatList.filter(seat =>
                seat.type === 'SEAT' && seat.enabled && seat.status === 'FREE' &&
                !blacklist.some(keyword => seat.name?.includes(keyword))
            ).map(seat => {
                const seatNumber = Utils.parseSeatNumberFromName(seat.name);
                if (isNaN(seatNumber)) return null;

                let category = "未分类", basePriority = Infinity;

                // --- 1. 正确分类阶段 (按数组顺序) ---
                // 直接按配置中的顺序检查，不再根据priority排序，确保分类正确
                for (const pref of preferences) {
                    if (Utils.matchesPreferenceRule(pref.rule, seatNumber)) {
                        category = pref.type;
                        basePriority = pref.priority; // 获取该分类的“基础优先级”
                        break;
                    }
                }

                // --- 2. 动态优先级计算阶段 ---
                let finalPriority = basePriority;
                
                // 如果用户明确选择了某个地段（不是'auto'模式）
                if (uiPref !== 'auto') {
                    if (category === uiPref) {
                        // 将用户选中的地段优先级提升至最高 (0)
                        finalPriority = 0;
                    } else {
                        // 对于其他未被选中的地段，保持其基础优先级，但需要加上一个偏移量
                        // 以确保它们永远排在被选中的地段之后。偏移量为1即可。
                        finalPriority = basePriority + 1;
                    }
                }
                
                return {
                    ...seat,
                    seatNumber,
                    category,
                    finalPriority, // 使用新的 finalPriority 进行排序
                    distance: Math.abs(seatNumber - Utils.DISTANCE_SORT_TARGET_SEAT),
                    isPreferred: preferredSeatNumbers.includes(seatNumber)
                };
            }).filter(Boolean);

            // --- 3. 最终排序阶段 ---
            return validSeats.sort((a, b) => {
                // 最高优先级：是否是“喜欢座位号”
                if (a.isPreferred !== b.isPreferred) return a.isPreferred ? -1 : 1;
                // 第二优先级：使用我们动态计算出的“最终优先级”
                if (a.finalPriority !== b.finalPriority) return a.finalPriority - b.finalPriority;
                // 第三优先级：距离目标座位40的远近
                return a.distance - b.distance;
            });
        },


        async ensureSeatListIsFetched() {
            for (let i = 0; i < this.FETCH_SEAT_MAX_RETRIES; i++) {
                try {
                    await VueAdapter.getSeats();
                    await new Promise(r => setTimeout(r, 300));
                    if (this.vm.seatList) {
                        return true;
                    }
                    Utils.log(`Seat list is null or undefined. Retrying (${i + 1}/${this.FETCH_SEAT_MAX_RETRIES})...`);
                } catch (e) {
                    await Utils.error(`Error fetching seats (${i + 1}/${this.FETCH_SEAT_MAX_RETRIES}):`, e.message);
                }
                await new Promise(r => setTimeout(r, this.FETCH_SEAT_RETRY_DELAY));
            }
            return false;
        },

        scheduleNextAttempt() {
            this.isActive = false;
            if (this.reservationTimer) clearTimeout(this.reservationTimer);
            const delay = ConfigManager.get('retryInterval') + (Math.random() * ConfigManager.get('randomizeDelay'));
            UIManager.updateStatus(`等待 ${Math.round(delay / 1000)} 秒后重试...`);
            this.reservationTimer = setTimeout(() => this.start(), delay);
        },

        async manualRefresh() {
             if (!this.vm) {
                UIManager.updateStatus('错误: 无法找到 Vue 实例。', 'error');
                return;
            }
            UIManager.updateStatus('正在手动刷新座位列表...', 'working');
            try {
                await VueAdapter.setTimeRange(ConfigManager.get('targetDate'), ConfigManager.get('targetStartTime'), ConfigManager.get('targetEndTime'));
                const fetchSuccess = await this.ensureSeatListIsFetched();
                if (fetchSuccess) {
                    const availableCount = this.vm.seatList.filter(s => s.type === 'SEAT' && s.enabled && s.status === 'FREE').length;
                    UIManager.updateStatus(`座位刷新成功。当前可选座位: ${availableCount}`, 'success');
                } else {
                    UIManager.updateStatus('座位刷新失败，无法从服务器获取列表。', 'error');
                }
            } catch (e) {
                await Utils.error('手动刷新座位失败:', e);
                UIManager.updateStatus(`错误: 手动刷新座位失败。(${e.message})`, 'error');
            }
        }
    };

    // =================================================================================
    // --- [主入口] Main Execution ---
    // =================================================================================
    async function main() {
        if (!window.location.href.includes('libseat.jlu.edu.cn/pages/reserve/seat-reserve/seat-choose-v2')) {
            Utils.log('Not on target page. Script will not run.');
            return;
        }
        GM_notification({
            title: GM.info.script.name, text: '脚本已启动，正在初始化...',
            image: 'https://www.jlu.edu.cn/__local/A/24/7D/2920253818AFBB1F55C97500B6E_67995171_B10E6.jpg',
            timeout: 3000
        });
        await ConfigManager.load();
        UIManager.create();
        UIManager.updateStatus('正在查找 Vue 实例...', 'working');
        const vueInstance = await Utils.waitForUniAppPageVm();
        if (vueInstance) {
            UIManager.updateStatus('Vue 实例已找到，脚本就绪。', 'success');
            await ReservationEngine.init(vueInstance);
        } else {
            UIManager.updateStatus('错误: 无法找到 Vue 实例。请刷新页面重试。', 'error');
        }
    }

    main().catch(e => Utils.error("An unhandled error occurred in main execution:", e));

})();
